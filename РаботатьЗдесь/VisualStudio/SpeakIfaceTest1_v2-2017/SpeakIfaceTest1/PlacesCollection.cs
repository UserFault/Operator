using System;
using System.Collections.Generic;

namespace SpeakIfaceTest1
{
    /// <summary>
    /// Коллекция мест для быстрого доступа из кода
    /// </summary>
    public class PlacesCollection
    {
        /// <summary>
        /// Словарь синонимов сущностей мест
        /// </summary>
        private Dictionary<String, Place> m_places;
        
        /// <summary>
        /// Default constructor
        /// </summary>
        public PlacesCollection()
        {
            this.m_places = new Dictionary<string, Place>();
        }

        /// <summary>
        /// Словарь синонимов сущностей мест
        /// </summary>
        public Dictionary<String, Place> Places
        {
            get { return m_places; }
            set { m_places = value; }
        }

        /// <summary>
        /// NT-Добавить в словарь синонимы для указанного места
        /// </summary>
        /// <param name="p">Объект места</param>
        public void Add(Place p)
        {
            //Если такое словосочетание уже есть в словаре, будет выброшено исключение, 
            //но часть синонимов места останется в словаре и не даст повторно его добавить.
            //Надо при обнаружении конфликта ключей откатывать состояние к предыдущему, 
            //удалив все уже добавленные элементы.
            //Их можно найти по одинаковому для всех них значению - объекту Места в паре ключ-значение.
            //Но все равно, одинаковые имена Мест - это проблема, которую надо учитывать 
            //при проектировании содержимого системы.
            //Это проблема методологии. Возможно, ее можно решить с помощью Контекста Задачи.
            //Это можно решить проще - перебором всех синонимов проверить что они отсутствуют в словаре.
			//А потом уже добавлять их в словарь смело.
			List<String> syno = p.GetSynonims();
            foreach (String s in syno)
            {
                if (m_places.ContainsKey(s))
                {
                    //тут может оказаться что синоним в словаре уже существует и ассоциирован с другим местом.
                    //я не могу просто пропустить такой ключ, хоть их и много еще в списке - нужно сообщить об этом пользователю
                    //и вообще откатить всю процедуру добавления места
                    //в данном случае - удалить из списка все ключи текущего места
                    Remove(p);
                    //и выдать исключение с сообщением о проблеме
                    throw new Exception(String.Format("Ошибка: Синоним {0} места {1} уже существует в словаре мест.", s, p.Title));
                }
                else
                    this.m_places.Add(s, p);
            }
            return;
        }
        /// <summary>
        /// NT-Удалить место из коллекции мест
        /// </summary>
        /// <param name="p">Удаляемое место</param>
        public void Remove(Place p)
        {
            //удалить все пары ключ-значение, где значением является указанное место.
            List<string> lis = new List<string>();
            //получим список всех ключей, к которым привязан этот объект
            //это может оказаться сравнительно долгим процессом, если в системе много мест - боее 10000.
            //но все равно нужен полный перебор всех элементов словаря, и ничего тут не ускорить.
            foreach (KeyValuePair<string, Place> kvp in this.m_places)
            {
                if (kvp.Value == p)
                    lis.Add(kvp.Key);
            }
            //Теперь удалим из словаря все эти ключи и их данные
            foreach (String s in lis)
                m_places.Remove(s);
            //тут вроде все.
            lis.Clear();
            return;
        }


        /// <summary>
        /// NT-Определить, есть ли такое имя в коллекции.
        /// </summary>
        /// <remarks>Это для упрощения вызывающего кода</remarks>
        /// <param name="name"></param>
        /// <returns></returns>
        internal bool ContainsPlace(string name)
        {
            return this.m_places.ContainsKey(name);
        }

        /// <summary>
        /// NT-Получить объект места по тексту аргумента.
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        public Place GetPlace(String text)
        {
            String t = text.Trim();
            if (m_places.ContainsKey(t))
            {
                return m_places[t];
            }
            else return null;
        }


        /// <summary>
        /// NR-Заполнить эту коллекцию местами вручную, описав их в коде
        /// </summary>
        internal void FillHardcodedPlaces()
        {
            //TODO: Заполнить эту коллекцию местами вручную, описав их в коде
            //TODO: Описать правила заполнения полей объекта, привести ссылки на форматы, документацию.

            Place p;
            
            //Это шаблон, образец, не трогать его!

            //p = new Place();
            ////заполнить вручную поля
            //p.Title = "";//Название сущности места, не обязательно, в работе механизма не используется
            //p.Synonim = "";//Список синонимов названия сущности, должны быть уникальными в системе.
            //p.Description = "";//Текст описания сущности, не обязателен, в работе механизма не используется
            //p.Path = "";//Веб-путь или файловый путь к месту
            //p.PlaceTypeExpression = "";//Перечисление типов сущности
            ////добавление в коллекцию 
            //p.ParseEntityTypeString();//Распарсить список типов сущностей
            //this.AddPlace(p);//добавить строку

            //////////////////////////////////////////////////////////////////////////////////////////

            p = new Place();
            //заполнить вручную поля
            p.Title = "Браузер";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "браузер, браузера, браузеру, браузером, браузере";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Программа веб-браузера как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Program Files\\Internet Explorer\\iexplore.exe";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::ВебБраузер<Файл::ФайлHtml, ВебАдрес>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Мой сайт";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "мой сайт, моего сайта, моему сайту, моим сайтом, моем сайте";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Мой сайт в интернете как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "http://www.meraman.com";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "ВебАдрес";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Мои проекты";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "мои проекты, моих проектов, моим проектам, моими проектами, моих проектах";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Мои проекты";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "V:\\Projects";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Каталог::МоиПроекты<Проект, Файл>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Студия";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "студия, студии, студию, студией";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Моя студия приложение как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Program Files\\Microsoft Visual Studio 9.0\\Common7\\IDE\\devenv.exe";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::IDE<Солюшен, Файл>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "MSDN help";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "msdn, мсдн, мсдна, мсдну, мсдном, мсдне";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Приложение MSDN";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = @"C:\Program Files\Common Files\Microsoft Shared\Help 9\dexplore.exe /helpcol ms-help://MS.MSDNQTR.v90.en /LaunchNamedUrlTopic DefaultPage";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::MSDN";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку
            
            p = new Place();
            //заполнить вручную поля
            p.Title = "Инвентарь";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "инвентарь, инвентаря, инвентарю, инвентарем, инвентаре";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Инвентарь приложение как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Program Files\\Inventory\\Inventory.exe";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::Инвентарь<Категория, Контейнер, Предмет>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Блокнот";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "блокнот, блокнота, блокноту,  блокнотом, блокноте";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Блокнот приожение как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "notepad.exe";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::ТекстовыйРедактор<Файл>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Дневник";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "дневник, дневника, дневнику, дневником, дневнике";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Дневник приложение как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "wiki:///V:/Projects/myWiki/MyWiki/MyWiki.wiki?page=Дневник2016";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "ВикиСтраница<Текст>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Калькулятор";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "калькулятор, калькулятора, калькулятору, калькулятором, калькуляторе";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Калькулятор приложение как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "calc.exe";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::Калькулятор";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Word";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "word, ворд, ворда, ворду, вордом, ворде";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Word Приложение как место";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Program Files\\Microsoft Office\\OFFICE11\\WINWORD.EXE";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::ТекстовыйРедактор<Файл::ДокументWord>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Мои Документы";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "мои документы, моих документов, моим документам, моими документами, моих документах";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Папка Мои документы";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Documents and Settings\\Smith John\\Мои документы";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Каталог::МоиДокументы<Каталог, Файл>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Моя музыка";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "моя музыка, моей музыки, моей музыке, мою музыку, моей музыкой";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Папка Коллекция Моя музыка";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Work\\Музыка";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Каталог::МояМузыка<Каталог, Файл, Файл::ФайлМузыки>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Плеер";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "плеер, плеера, плееру, плеером, плеере";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Приложение плеер";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Program Files\\Windows Media Player\\wmplayer.exe";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Приложение::АудиоПлеер<Файл::ФайлМузыки, Файл::Плейлист>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "Хиты";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "хиты, хитов, хитам, хитами, хитах";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Плейлист отобранных мною хитов";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "C:\\Documents and Settings\\Smith John\\Мои документы\\Моя музыка\\My Playlists\\хиты.wpl";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "Файл::Плейлист<Файл::ФайлМузыки>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

            p = new Place();
            //заполнить вручную поля
            p.Title = "ВикиРИ";//Название сущности места, не обязательно, в работе механизма не используется
            p.Synonim = "викири";//Список синонимов названия сущности, должны быть уникальными в системе.
            p.Description = "Вики проекта Речевой интерфейс";//Текст описания сущности, не обязателен, в работе механизма не используется
            p.Path = "wiki:///V:/Projects/РечевойИнтерфейс/SpeakWiki/SpeakWiki.wiki?page=SpeakWiki";//Веб-путь или файловый путь к месту
            p.PlaceTypeExpression = "ВикиСтраница<Текст>";//Перечисление типов сущности
            //добавление в коллекцию 
            p.ParseEntityTypeString();//Распарсить список типов сущностей
            this.Add(p);//добавить строку

        }


        /// <summary>
        /// NT-Заполнить коллекцию местами из списка
        /// </summary>
        /// <param name="list"></param>
        internal void FillFromDb(List<Place> list)
        {
            foreach (Place p in list)
            {
                //p.ParseEntityTypeString(); это уже сделано при чтении из БД
                this.Add(p);
            }
            return;
        }
        ///// <summary>
        ///// for first time only
        ///// </summary>
        ///// <param name="m_db"></param>
        //internal void FillDbTest(DbAdapter db)
        //{
        //    this.FillHardcodedPlaces();
        //    foreach (Place p in m_places.Values)
        //        db.AddPlace(p);
        //    return;
        //}

        /// <summary>
        /// NT-Очистить коллекцию
        /// </summary>
        internal void Clear()
        {
            this.m_places.Clear();
        }


        /// <summary>
        /// NT-Выбрать из БД Места по названию, без учета регистра символов
        /// </summary>
        /// <param name="placeTitle">Название места</param>
        /// <returns>Возвращает список мест с указанным названием</returns>
        internal List<Place> getByTitle(string placeTitle)
        {
            //словарь имеет ключ - синоним, так что в словаре по 8 штук одних и тех же объектов мест.
            //поэтому создадим еще один словарь - временный для уникализации объектов мест. 
            List<Place> result = new List<Place>();
            Dictionary<int, Place> tdic = new Dictionary<int, Place>();
            foreach (Place p in this.m_places.Values)
                if (String.Equals(p.Title, placeTitle, StringComparison.OrdinalIgnoreCase))
                {
                    if (!tdic.ContainsKey(p.TableId))
                        tdic.Add(p.TableId, p);
                }
            //тут перенесем содержимое словаря в выходной список и уничтожим словарь
            result.AddRange(tdic.Values);
            tdic.Clear();
            tdic = null;

            return result;
        }
    }
}
